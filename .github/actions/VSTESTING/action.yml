name: VSTest Reusable Workflow

inputs:
  runsOn:
    required: true
  dotnet-version:
    required: true
  testSelector:
    required: true
    default: "testAssemblies"
  testAssemblyVer2:
    required: true
  configuration:
    required: true
  platform:
    required: false
  code-coverage-enabled:
    required: false
  test-run-title:
    required: false
  run-in-parallel:
    required: false
  testPlan:
    required: false
  testSuite:
    required: false
  testConfiguration:
    required: false
  tcmTestRun:
    required: false
  uiTests:
    required: false
  vsTestVersion:
    required: false
  vstestLocation:
    required: true
  diagnosticsEnabled:
    required: false
  rerunFailedTests:
    required: false
  rerunType:
    required: false
  rerunMaxAttempts:
    required: false
  dontDistribute:
    required: false
  searchFolder:
    required: true
  testFiltercriteria:
    required: false
  runOnlyImpactedTests:
    required: false
    default: false
  runAllTestsAfterXBuilds:
    required: false
    default: "50"

runs:
  using: 'composite'
  steps:
    - name: Restore dependencies
      shell: pwsh
      run: dotnet restore

    - name: Build solution
      shell: pwsh
      run: dotnet build --configuration ${{ inputs.configuration }} --no-restore

    - name: Debug Directory Structure
      shell: pwsh
      run: |
        $workingDirectory = "${{ env.GITHUB_WORKSPACE }}"
        Set-Location -Path $workingDirectory
        Write-Host "Listing all files in the working directory:"
        Get-ChildItem -Path $workingDirectory -Recurse | ForEach-Object { Write-Host $_.FullName }

    - name: Run tests with Visual Studio Test Runner
      shell: pwsh
      env:
        SEARCH_FOLDER: ${{ inputs.searchFolder }}
      run: |
        $workingDirectory = $env:SEARCH_FOLDER
        Set-Location -Path $workingDirectory

        # Validate and sanitize vstestLocation path
        $vstestPath = "${{ inputs.vstestLocation }}"
        if ([string]::IsNullOrWhiteSpace($vstestPath)) {
          Write-Error "vstestLocation input is empty or invalid."
          exit 1
        }
        $vstestPath = [System.IO.Path]::GetFullPath($vstestPath)
        if (-not (Test-Path -Path $vstestPath -PathType Leaf)) {
          Write-Error "vstest.console.exe not found at path: $vstestPath"
          exit 1
        }

        # Resolve test assemblies from the bin directory, excluding obj folder
        $testAssemblies = Get-ChildItem -Path $workingDirectory -Recurse -File -Include *.dll |
          Where-Object { $_.FullName -notmatch 'obj' } | ForEach-Object { $_.FullName }
        if (-not $testAssemblies) {
          Write-Error "No test assemblies found."
          exit 1
        }

        Write-Host "Resolved test assemblies:"
        $testAssemblies | ForEach-Object { Write-Host $_ }

        foreach ($testAssembly in $testAssemblies) {
          Write-Host "Test Assembly Path: $testAssembly"

          # Construct arguments for vstest.console.exe
          $vstestArgs = @()
          $vstestArgs += "`"$testAssembly`"" 
          if (${{ inputs.code-coverage-enabled }}) { $vstestArgs += '/EnableCodeCoverage' }
          if (${{ inputs.run-in-parallel }}) { $vstestArgs += '/Parallel' }
          if (${{ inputs.diagnosticsEnabled }}) { $vstestArgs += '/Diag:logfile.txt' }
          if (${{ inputs.rerunFailedTests }}) { $vstestArgs += "/Rerun:${{ inputs.rerunType }}" }
          if (${{ inputs.testFiltercriteria }}) { 
            $vstestArgs += "/TestCaseFilter:`"${{ inputs.testFiltercriteria }}`"" 
          }
          if (${{ inputs.runOnlyImpactedTests }}) { 
            $vstestArgs += "/ImpactedTests"
            $vstestArgs += "/RunAllTestsAfter:${{ inputs.runAllTestsAfterXBuilds }}"
          }
          if (${{ inputs.uiTests }}) { $vstestArgs += "/UITests" }

          Write-Host "Executing: `"$vstestPath`" $($vstestArgs -join ' ')"
          & "$vstestPath" @vstestArgs
        }
